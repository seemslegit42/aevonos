'use server';

/**
 * @fileOverview This file defines the BEEP agent kernel using LangGraph.
 * BEEP (Behavioral Event & Execution Processor) is the central orchestrator of ΛΞVON OS.
 *
 * - processUserCommand - The function to call to process the command.
 * - UserCommandInput - The input type for the processUserCommand function.
 * - UserCommandOutput - The output type for the processUserCommand function.
 */

import { z } from 'zod';
import { StateGraph, END, ToolNode } from '@langchain/langgraph';
import {
  AIMessage,
  BaseMessage,
  HumanMessage,
  ToolMessage,
} from '@langchain/core/messages';
import { Tool } from '@langchain/core/tools';
import { zodToJsonSchema } from 'zod-to-json-schema';
import { RunnableLambda } from '@langchain/core/runnables';

import { geminiModel } from '@/ai/genkit';
import { drSyntaxCritique } from '@/ai/agents/dr-syntax';
import {
  DrSyntaxInputSchema,
  DrSyntaxOutputSchema,
} from '@/ai/agents/dr-syntax-schemas';
import { aegisAnomalyScan } from '@/ai/agents/aegis';
import { AegisAnomalyScanOutputSchema } from './aegis-schemas';
import { createContactInDb, CreateContactInputSchema, ContactSchema } from '@/ai/tools/crm-tools';


// Schemas from the original BEEP agent, preserved for the public contract.
const LaunchableAppTypeSchema = z.enum([
  'file-explorer',
  'terminal',
  'echo-control',
]);

const AppToLaunchSchema = z.object({
  type: LaunchableAppTypeSchema,
  title: z.string().optional().describe('A specific title for this app instance, if applicable. Otherwise, the default will be used.'),
  description: z.string().optional().describe('A specific description for this app instance, if applicable. Otherwise, the default will be used.'),
});

const CrmAgentReportSchema = z.object({
  agent: z.literal('crm'),
  report: ContactSchema.describe('The details of the newly created contact.'),
});

const AgentReportSchema = z.discriminatedUnion('agent', [
  z.object({
    agent: z.literal('dr-syntax'),
    report: DrSyntaxOutputSchema.describe(
      'The full report object from the Dr. Syntax agent.'
    ),
  }),
  z.object({
    agent: z.literal('aegis'),
    report: AegisAnomalyScanOutputSchema.describe(
      'The full report object from the Aegis agent.'
    ),
  }),
  CrmAgentReportSchema,
]);

export const UserCommandInputSchema = z.object({
  userCommand: z.string().describe('A natural language command from the user about what they want to do or launch.'),
});
export type UserCommandInput = z.infer<typeof UserCommandInputSchema>;

export const UserCommandOutputSchema = z.object({
  appsToLaunch: z.array(AppToLaunchSchema).describe('An array of Micro-Apps that BEEP has determined should be launched on the Canvas based on the user command. This can be empty.'),
  agentReports: z.array(AgentReportSchema).optional().describe("An array of reports generated by other agents after BEEP delegated tasks to them. This should be populated with the result of any tool calls."),
  suggestedCommands: z.array(z.string()).describe('If no specific app can be launched or action taken, provide an array of suggested commands or actions the user could take next. This is for conversational repair.'),
  responseText: z.string().describe('A natural language response to the user confirming the action or asking for clarification.'),
});
export type UserCommandOutput = z.infer<typeof UserCommandOutputSchema>;


// LangChain Tool Definitions
class DrSyntaxTool extends Tool {
  name = 'critiqueContent';
  description = 'Sends content to Dr. Syntax for a harsh but effective critique. Use this when a user asks for a review, critique, or feedback on a piece of text, code, or a prompt. Extract the content and content type from the user command.';
  schema = DrSyntaxInputSchema;
  
  async _call(input: z.infer<typeof DrSyntaxInputSchema>) {
    const result = await drSyntaxCritique(input);
    return JSON.stringify(result);
  }
}

class AegisScanTool extends Tool {
    name = 'runAegisScan';
    description = 'Initiates a security scan using the Aegis subsystem. Use this when the user asks to "run a scan", "check for threats", or other security-related commands.';
    schema = z.object({});
    
    async _call(input: z.infer<typeof this.schema>) {
        const result = await aegisAnomalyScan({ activityDescription: 'User initiated a manual security scan via BEEP.' });
        return JSON.stringify(result);
    }
}

class CreateContactTool extends Tool {
    name = 'createContact';
    description = 'Creates a new contact in the system. Use this when the user asks to "add a contact", "new contact", etc. Extract their details like name, email, and phone from the user command.';
    schema = CreateContactInputSchema;

    async _call(input: z.infer<typeof CreateContactInputSchema>) {
        const result = await createContactInDb(input);
        return JSON.stringify(result);
    }
}


const tools = [new DrSyntaxTool(), new AegisScanTool(), new CreateContactTool()];
const modelWithTools = geminiModel.bind({
  tools: tools.map(tool => ({
    type: 'function',
    function: {
      name: tool.name,
      description: tool.description,
      parameters: zodToJsonSchema(tool.schema),
    },
  })),
});


// LangGraph State
interface AgentState {
  messages: BaseMessage[];
}

const callModel = async (state: AgentState) => {
  const { messages } = state;
  const response = await modelWithTools.invoke(messages);
  return { messages: [response] };
};

const shouldContinue = (state: AgentState) => {
  const { messages } = state;
  const lastMessage = messages[messages.length - 1];
  if (
    'tool_calls' in lastMessage &&
    lastMessage.tool_calls &&
    lastMessage.tool_calls.length > 0
  ) {
    return 'tools';
  }
  return 'end';
};

const toolNode = new ToolNode<AgentState>(tools);

const workflow = new StateGraph<AgentState>({
  channels: {
    messages: {
      value: (x, y) => x.concat(y),
      default: () => [],
    },
  },
});

workflow.addNode('agent', callModel);
workflow.addNode('tools', toolNode);
workflow.addConditionalEdges('agent', shouldContinue, {
  continue: 'tools',
  end: END,
});
workflow.addEdge('tools', 'agent');
workflow.setEntryPoint('agent');

const app = workflow.compile();

// Final output formatter
const finalResponseParser = new RunnableLambda({
    func: async (input: { messages: BaseMessage[] }) => {
        const finalContent = input.messages.slice(-1)[0].content as string;
        // This is a simplified parser. A more robust implementation might use another LLM call
        // with JSON mode to guarantee the output schema. For now, we parse the string content.
        try {
            // A simple heuristic to check if the content is likely our JSON object
            if (finalContent.includes("responseText") && finalContent.includes("appsToLaunch")) {
                const jsonContent = JSON.parse(finalContent);
                return UserCommandOutputSchema.parse(jsonContent);
            }
        } catch (e) {
             // Fallback if parsing fails
             console.error("Final response parsing failed, using fallback.", e);
        }
        
        // Fallback for non-JSON or parsing errors
        return {
            responseText: finalContent,
            appsToLaunch: [],
            agentReports: [],
            suggestedCommands: [],
        };
    }
});


// Public-facing function to process user commands
export async function processUserCommand(input: UserCommandInput): Promise<UserCommandOutput> {
  const prompt = `You are BEEP (Behavioral Event & Execution Processor), the central orchestrator of ΛΞVON OS. Your primary function is to interpret user commands, use tools to delegate to other agents, and translate the results into a final JSON object conforming to the UserCommandOutputSchema.

  Your process:
  1. Analyze the user's command.
  2. If the command requires a tool (e.g., creating a contact, running a scan, getting a critique), you MUST use the appropriate tool.
  3. If the user is asking to open an app (e.g., "open terminal"), populate the 'appsToLaunch' array in your final JSON output. The available apps are: 'file-explorer', 'terminal', 'echo-control'.
  4. After all tools have been called and you have all the information, construct a final, single JSON object that strictly follows this schema: ${JSON.stringify(zodToJsonSchema(UserCommandOutputSchema))}.
  5. Your final response MUST be ONLY this JSON object. Do not add any conversational text around it.
  6. The 'agentReports' array in the JSON output should be populated with the results of any tool calls you made. Parse the stringified JSON from the tool output.

  User Command: ${input.userCommand}`;


  const result = await app.invoke({
    messages: [new HumanMessage(prompt)],
  });

  // Create a structured list of agent reports from tool messages
  const agentReports: z.infer<typeof AgentReportSchema>[] = [];
  result.messages.forEach(msg => {
    if (msg instanceof ToolMessage) {
        try {
            const toolOutput = JSON.parse(msg.content as string);
            if(msg.tool_call_id) {
                if (msg.name === 'critiqueContent') {
                    agentReports.push({ agent: 'dr-syntax', report: DrSyntaxOutputSchema.parse(toolOutput) });
                } else if (msg.name === 'runAegisScan') {
                    agentReports.push({ agent: 'aegis', report: AegisAnomalyScanOutputSchema.parse(toolOutput) });
                } else if (msg.name === 'createContact') {
                    agentReports.push({ agent: 'crm', report: ContactSchema.parse(toolOutput) });
                }
            }
        } catch (e) {
            console.error("Failed to parse tool message content:", e);
        }
    }
  });


  // Take the last AIMessage, which should be the final JSON object.
  const lastMessage = result.messages[result.messages.length - 1];
  if (lastMessage._getType() === 'ai' && typeof lastMessage.content === 'string') {
      try {
          const parsed = UserCommandOutputSchema.parse(JSON.parse(lastMessage.content));
          // Inject the agent reports gathered from the tool calls
          parsed.agentReports = agentReports;
          return parsed;
      } catch (e) {
          console.error("Failed to parse final AI message into UserCommandOutputSchema", e);
          // Fallback if parsing fails
          return {
              responseText: lastMessage.content || "I apologize, but I encountered an issue processing the final response.",
              appsToLaunch: [],
              agentReports: agentReports, // Still return reports if we have them
              suggestedCommands: ["Try rephrasing your command."],
          };
      }
  }

  // Final fallback
  return {
    responseText: "My apologies, I was unable to produce a valid response.",
    appsToLaunch: [],
    agentReports: [],
    suggestedCommands: ["Please try again."],
  };
}
